<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Compiler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Compiler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var cheerio = require('cheerio');
var exprjs = new (require('exprjs'))();
var fs = require('fs');
var path = require('path');

/**
 * Returns the first directory where a node_modules directory exists.
 */
function basePath() {
  var _path = __dirname;

  if (_path.indexOf('node_modules/goji') !== -1) {
    while (!fs.existsSync(_path + '/node_modules') || _path.substr(-4) === 'goji') {
      _path = path.resolve(_path + '/..');
    }
  } else {
    while (!fs.existsSync(_path + '/node_modules')) {
      _path = path.resolve(_path + '/..');
    }
  }

  return _path;
}

function extendObj(a, b) {
  Object.keys(b).forEach(function keyIterator(val) {
    if (a.hasOwnProperty(val)) {
      a[val] = b[val];
    }
  });
}

function loadTemplateNamed(name) {
  // TODO: cache these?
  return fs.readFileSync(path.resolve(name)).toString();
}

/**
 * Provides methods for parsing, compiling, and rendering templates.
 *
 * @param options
 * @returns {Compiler}
 * @constructor
 */
function Compiler(options) {
  if (! (this instanceof Compiler)) {
    return new Compiler();
  }

  if (options) {
    var self = Object.getPrototypeOf(this);
    extendObj(self.options, options);
  }
}

Compiler.prototype = {
  options: {
    templatesDir: path.resolve(basePath() + '/html'),
    templatesExt: '.html'
  }
};

/**
 * &lt;p>Parses for elements that have a &lt;code>g-each&lt;/code> attribute and renders
 * them. If the element also has a &lt;code>g-text&lt;/code> attribute, then the
 * element is used as the template. Otherwise, the content of the parent
 * element is used as the template. In either case, the final result will be
 * that the parent element's content is replaced with the rendered template.&lt;/p>
 *
 * &lt;p>Additionally, an extra context will be present during the parsing of the
 * template. This extra context is an object named &lt;code>iter&lt;/code>. It has a
 * property &lt;code>i&lt;/code> that indicates the iteration number. It also has
 * two boolean properties: &lt;code>odd&lt;/code> and &lt;code>even&lt;/code>. These two
 * properties can be used as shortcuts to determine whether the iteration
 * number is odd or even.&lt;/p>
 *
 * @param {object} $ A cheerio object that respresents the template
 * @param {object} context The context for the template actions
 * @param {object} gContext A context of extra information provided by Goji
 * @returns {object} The modified cheerio object
 * @since 0.2.0
 * @private
 */
Compiler.prototype._each = function _each($, context, gContext) {
  var self = this;
  var iter = {
    i: 0,
    get odd() {
      return (this.i % 2) !== 0;
    },
    get even() {
      return (this.i % 2) === 0;
    }
  };

  return $('[g-each]').each(function gEach(i, elem) {
    // This thing is a mess
    iter.i = 0;
    var $elem = $(elem);
    var parts = $elem.attr('g-each').split(' in ').map(function(val) {
      return val.trim();
    });

    // Retrieve the desired array from the context
    var expr = exprjs.parse(parts[1]);
    var list = exprjs.run(expr, context, gContext);

    // Evaluate the subsitution expression if it is directly on the element
    var gText = $elem.attr('g-text');
    if (gText) {
      var expr2 = exprjs.parse($elem.attr('g-text'));
      $elem.removeAttr('g-text');
    }

    $elem.removeAttr('g-each'); // remove it so we don't run it again
    var varName = parts[0];
    var _context = {};
    _context[varName] = '';

    // Prepare our target DOM nodes
    var $parent = $elem.parent();
    var $node = $elem.clone();
    $parent.html('');

    var iterRender = function(){};
    if (gText) {
      iterRender = function iterRender1(item) {
        _context[varName] = item;
        var result = exprjs.run(expr2, _context, iter);
        $node.html(result);
        $parent.append($node.clone());

        iter.i += 1;
      };
    } else {
      var innerTemplate = $node.html();
      iterRender = function iterRender2(item) {
        _context[varName] = item;
        var result = self._render(innerTemplate, _context, iter);
        $node.html(result);
        $parent.append($node.clone());

        iter.i += 1;
      };
    }

    // Finally loop through and render
    list.forEach(iterRender);

    return $elem;
  });
};

/**
 * This method is used to parse a given &lt;code>template&lt;/code> for included
 * blocks from other templates. An include does not replace the element on
 * which the &lt;code>g-include&lt;/code> attribute is present. The include takes
 * the content of the denoted template and inserts it as the content of
 * &lt;code>g-include&lt;/code> element.
 *
 * @param template A template to parse for elements with &lt;code>g-include&lt;/code>
 *        attributes
 * @returns {string} The parsed template with includes replaced
 * @private
 */
Compiler.prototype._include = function _include(template) {
  var $ = cheerio.load(template);

  this._ir($, 'g-include', function($elem, $newContent) {
    $elem.html($newContent.html());
    $elem.attr('g-include', null);
  });

  return $.html();
};

/**
 * This method is used to parse a given &lt;code>template&lt;/code> for replaced
 * blocks from other templates. A replace fully replaces the element on
 * which the &lt;code>g-replace&lt;/code> attribute is present. The replace takes
 * the content of the denoted template and inserts it in the same DOM location
 * of &lt;code>g-replace&lt;/code> element.
 *
 * @param template A template to parse for elements with &lt;code>g-replace&lt;/code>
 *        attributes
 * @returns {string} The parsed template with includes replaced
 * @private
 */
Compiler.prototype._replace = function _replace(template) {
  var $ = cheerio.load(template);

  this._ir($, 'g-replace', function($elem, $content) {
    $elem.replaceWith($content);
  });

  return $.html();
};

/**
 * Utility method used by {@link Compiler#_include} and
 * {@link Compiler#replace}.
 *
 * @param $ A cheerio object representing a template to work on
 * @param {string} attrName The attribute to look for, 'g-include' or 'g-replace'
 * @param {Function} action A function accepting &lt;code>$elem&lt;/code> and &lt;code>$newContent&lt;/code>
 * @returns {object} The modified cheerio object
 * @private
 */
Compiler.prototype._ir = function _ir($, attrName, action) {
  var self = this;

  return $('[' + attrName + ']').each(function _irParser(i, elem) {
    var $elem = $(elem);
    var parts = $elem.attr(attrName).split('::').map(function(elem) {
      return elem.trim();
    });

    var child = loadTemplateNamed(
      self.options.templatesDir + '/' + parts[0] + self.options.templatesExt
    );

    var parsedChild = self._parse(child);
    var $newContent = $(parts[1], parsedChild);

    action($elem, $newContent);

    return $elem.html();
  });
};

/**
 * Used to perform all parsing operations necessary to compile a template.
 *
 * @param template The template to parse for compilation
 * @returns {string} The fully parsed (compiled) template
 * @private
 */
Compiler.prototype._parse = function _parse(template) {
  var _template = this._include(template);
  _template = this._replace(_template);
  return _template;
};

/**
 * Used to run through all supported attributes of a compiled template and
 * perform their actions.
 *
 * @param {string} template A template as compiled by {@link Compiler#_parse}
 * @param {object} context The object to use as the context for actions
 * @param {object} gContext A context of extra information provided by Goji
 * @returns {string} The rendered template
 * @private
 */
Compiler.prototype._render = function _render(template, context, gContext) {
  var $ = cheerio.load(template);

  this._each($, context, gContext); // Should be parsed first
  this._text($, context, gContext);

  return $.html();
};

/**
 * Looks through a compiled template for &lt;code>g-text&lt;/code> attributes and
 * parses them.
 *
 * @param {object} $ A cheerio object that respresents the template
 * @param {object} context The context for the the template actions
 * @param {object} gContext A context of extra information provided by Goji
 * @returns {object} The modified cheerio object
 * @private
 */
Compiler.prototype._text = function _text($, context, gContext) {
  return $('[g-text]').each(function(i, elem) {
    var $elem = $(elem);
    var expression = $elem.attr('g-text');
    var parsed = exprjs.parse(expression);
    var result = exprjs.run(parsed, context, gContext);

    $elem.text(result);
    $elem.attr('g-text', null);
    return $elem;
  });
};

/**
 * Returned from the {@link Compiler#compile} method when a template has been
 * compiled. This function allows you to render the compiled template
 * with substitued values.
 *
 * @typedef {Function} Compiler~RenderFunction
 * @param {object} context An object of values that will be substituted in
 *        the rendered template
 * @param {object} options Not used (yet)
 */

/**
 * &lt;p>An object literal that has the following properties:&lt;/p>
 * &lt;ul>
 *   &lt;li>
 *     &lt;code>templatesDir&lt;/code>: The location where templates are stored.
 *     This should be the full path (use `path.resolve`). If it is not present,
 *     then it will be set to an "html" directory that is in the same
 *     directory as a node_modules directory.
 *   &lt;/li>
 *   &lt;li>
 *     &lt;code>templatesExt&lt;/code>: The file extension used on template files.
 *     This defaults to ".html". Note that it should include the leading dot.
 *   &lt;/li>
 * &lt;/ul>
 * @typedef {object} Compiler~Options
 */

/**
 * Parses a given &lt;code>template&lt;/code> for &lt;code>g-include&lt;/code> and
 * &lt;code>g-replace&lt;/code> blocks. Said blocks are dealt with appropriately.
 *
 * @param {string} template The template to compile
 * @param {Compiler~Options} options Options to be used by the compiler
 * @returns {Compiler~RenderFunction} A function to use for rendering the
 *          compiled template
 */
Compiler.prototype.compile = function compile(template, options) {
  var self = this;

  if (options) {
    // TODO: decouple this from the full options so that we are not
    // overwriting global Compiler options every compile
    extendObj(self.options, options);
  }

  var compiledTemplate = self._parse(template);

  return function(context, options) {
    return self._render(compiledTemplate, context);
  };
};

exports = module.exports = Compiler;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Compiler.html">Compiler</a></li></ul><h3>Global</h3><ul><li><a href="global.html#basePath">basePath</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha11</a> on Thu Dec 11 2014 22:11:19 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
